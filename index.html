<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chroma Loop: Secure Zip</title>
    <style>
        :root {
            --bg: #ffffff;
            --surface: #f8fafc;
            --wall: #0f172a;
            --accent: #4f46e5;
            --cell: 36px;
        }

        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: var(--bg); color: #1e293b;
            margin: 0; padding: 10px;
            display: flex; flex-direction: column; align-items: center;
            overscroll-behavior: none;
            user-select: none; -webkit-user-select: none;
        }

        .header { text-align: center; margin-bottom: 10px; pointer-events: none; }
        
        .game-wrapper {
            display: flex; flex-direction: column; gap: 10px;
            align-items: center; width: 100%; max-width: 500px;
        }

        .grid-container {
            position: relative;
            background: var(--surface);
            padding: 10px; border-radius: 12px;
            touch-action: none; 
            overflow: hidden; /* Prevent visual bleed */
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(13, var(--cell));
            grid-template-rows: repeat(13, var(--cell));
        }

        .cell { 
            width: var(--cell); height: var(--cell); 
            display: flex; justify-content: center; align-items: center; 
            position: relative;
        }

        .heatmap-overlay {
            position: absolute; width: 100%; height: 100%;
            pointer-events: none; opacity: 0.4; z-index: 1;
        }

        canvas { position: absolute; top: 10px; left: 10px; pointer-events: none; }
        #wall-canvas { z-index: 4; }
        #path-canvas { z-index: 5; }

        .ball-anchor {
            width: 28px; height: 28px;
            display: flex; justify-content: center; align-items: center;
            border-radius: 50%; z-index: 10;
            background-color: currentColor;
            pointer-events: none;
        }
        
        .ball-anchor span { color: var(--surface); font-weight: 900; font-size: 15px; mix-blend-mode: screen; }
        .ball-anchor.collected { opacity: 0.15; transform: scale(0.6); }

        .sidebar { width: 100%; display: flex; flex-direction: column; gap: 8px; }
        .card { background: white; padding: 12px; border-radius: 12px; border: 1px solid #e2e8f0; }

        button {
            padding: 12px; border: none; border-radius: 8px;
            background: var(--wall); color: white;
            font-weight: 800; cursor: pointer; text-transform: uppercase; font-size: 10px;
        }

        #lb-list { max-height: 120px; overflow-y: auto; scrollbar-width: thin; }
        .lb-item { display: grid; grid-template-columns: 25px 1fr auto; padding: 6px 0; border-bottom: 1px solid #f1f5f9; align-items: center; }
        .lb-rank { font-weight: 900; color: #cbd5e1; font-size: 0.75rem; }
        .lb-stats { text-align: right; font-size: 0.55rem; color: #94a3b8; font-weight: 700; }

        .histo-container { display: flex; align-items: flex-end; gap: 2px; height: 35px; margin-top: 8px; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        .histo-bar { flex: 1; background: var(--accent); min-width: 4px; border-top-left-radius: 1px; border-top-right-radius: 1px; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.9); display: none;
            justify-content: center; align-items: center; z-index: 100;
        }
        .modal { background: white; padding: 25px; border-radius: 16px; width: 85%; max-width: 300px; text-align: center; }
        .modal input { width: 100%; padding: 12px; margin: 10px 0; border: 1px solid #ddd; border-radius: 8px; box-sizing: border-box; }

        @media (max-width: 450px) { :root { --cell: 28px; } .ball-anchor { width: 22px; height: 22px; } .ball-anchor span { font-size: 12px; } }
    </style>
</head>
<body>

    <div class="header">
        <h1 style="margin:0; font-size: 1.1rem; letter-spacing: 1px;">CHROMA LOOP #<span id="m-id">1</span></h1>
        <div style="font-size: 0.6rem; font-weight: 900; color: #94a3b8;">
            <span id="timer">0.0s</span> | STEPS: <span id="step-count">0</span> | NODES: <span id="p-count">0</span>/9
        </div>
    </div>

    <div class="game-wrapper">
        <div class="grid-container" id="touch-zone">
            <div id="grid"></div>
            <canvas id="wall-canvas"></canvas>
            <canvas id="path-canvas"></canvas>
        </div>

        <div class="sidebar">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <button onclick="changeMaze(-1)" style="background:#f1f5f9; color:#64748b;">Prev</button>
                <button onclick="changeMaze(1)" style="background:#10b981;">Next Maze</button>
            </div>
            
            <div class="card">
                <div style="font-weight: 900; font-size: 0.6rem; color: #94a3b8; text-transform: uppercase;">Standings</div>
                <div id="lb-list"></div>
            </div>

            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="font-weight: 900; font-size: 0.6rem; color: #94a3b8; text-transform: uppercase;">Uniqueness</div>
                    <button onclick="toggleHeatmap()" style="padding: 2px 6px; font-size: 7px; background: var(--accent);">Map</button>
                </div>
                <div id="rarity-text" style="font-size: 0.65rem; margin-top: 4px; color: var(--accent); font-weight: bold;">Zip to solve...</div>
                <div class="histo-container" id="histogram"></div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <button onclick="toggleNumbers()" style="background:#f1f5f9; color:#64748b;">Toggle #</button>
                <button onclick="resetMaze()" style="background:#ef4444;">Restart</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="win-modal">
        <div class="modal">
            <h2 style="margin:0; font-size: 1.1rem; color: var(--accent);">LOOP SECURED</h2>
            <div id="final-stats" style="font-size: 0.8rem; color: #64748b; margin: 15px 0;"></div>
            <input type="text" id="p-name" placeholder="HANDLE" maxlength="12">
            <button style="width:100%" onclick="saveScore()">SUBMIT</button>
        </div>
    </div>

<script>
    const S = 13;
    let CS = 36;
    const colors = ["#ef4444", "#3b82f6", "#10b981", "#f59e0b", "#8b5cf6", "#ec4899", "#06b6d4", "#14b8a6", "#6366f1"];
    
    let history = JSON.parse(localStorage.getItem('chroma_v13_secure_zip') || '[]');
    let curIdx = history.length > 0 ? history.length - 1 : 0;
    let showNums = true;
    
    let state = { 
        cells: [], balls: {}, player: {x:0, y:0}, collected: new Set(), path: [], gameOver: false,
        startTime: null, duration: 0, timerInterval: null, showHeatmap: true, isDragging: false
    };

    const pathCanvas = document.getElementById('path-canvas');
    const pathCtx = pathCanvas.getContext('2d');
    const wallCanvas = document.getElementById('wall-canvas');
    const wallCtx = wallCanvas.getContext('2d');

    function updateScale() {
        CS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
        const totalSize = S * CS;
        pathCanvas.width = totalSize; pathCanvas.height = totalSize;
        wallCanvas.width = totalSize; wallCanvas.height = totalSize;
        drawWalls(); drawPath();
    }

    function init() {
        if (!history[curIdx]) generate();
        load(curIdx);
        window.addEventListener('resize', updateScale);
        setupInteraction();
        setupKeyboard();
        updateScale();
    }

    function generate() {
        let cells = Array.from({length: S}, (_, y) => Array.from({length: S}, (_, x) => ({
            x, y, w: {t:false, r:false, b:false, l:false}
        })));
        let walls = 0;
        while(walls < 28) {
            let rx = Math.floor(Math.random()*S), ry = Math.floor(Math.random()*S);
            let s = ['t','r','b','l'][Math.floor(Math.random()*4)];
            if(!cells[ry][rx].w[s]) {
                cells[ry][rx].w[s] = true;
                if(s === 't' && ry > 0) cells[ry-1][rx].w.b = true;
                if(s === 'b' && ry < S-1) cells[ry+1][rx].w.t = true;
                if(s === 'l' && rx > 0) cells[ry][rx-1].w.r = true;
                if(s === 'r' && rx < S-1) cells[ry][rx+1].w.l = true;
                walls++;
            }
        }
        let balls = {};
        for(let i=1; i<=9; i++) {
            let rx, ry;
            do { rx = Math.floor(Math.random()*S); ry = Math.floor(Math.random()*S); } 
            while (Object.values(balls).some(b => b.x === rx && b.y === ry));
            balls[i] = {x: rx, y: ry};
        }
        history.push({cells, balls, id: history.length + 1});
        localStorage.setItem('chroma_v13_secure_zip', JSON.stringify(history));
    }

    function load(idx) {
        const d = history[idx];
        state.cells = d.cells; state.balls = d.balls;
        state.player = {x: d.balls[1].x, y: d.balls[1].y};
        state.collected = new Set();
        state.path = [{x: state.player.x, y: state.player.y, c: colors[0]}];
        state.gameOver = false; state.startTime = null; state.duration = 0;
        clearInterval(state.timerInterval);
        document.getElementById('m-id').innerText = d.id;
        document.getElementById('timer').innerText = "0.0s";
        renderGrid(); drawWalls(); drawPath(); updateLB(); updateAnalytics();
    }

    function drawWalls() {
        const totalSize = S * CS;
        wallCtx.clearRect(0, 0, totalSize, totalSize);
        wallCtx.lineWidth = 5; wallCtx.strokeStyle = '#0f172a';
        wallCtx.lineCap = 'round'; wallCtx.lineJoin = 'round';
        wallCtx.beginPath();
        for(let y=0; y<S; y++) {
            for(let x=0; x<S; x++) {
                const cell = state.cells[y][x];
                if(cell.w.r && x < S-1) { wallCtx.moveTo((x+1)*CS, y*CS); wallCtx.lineTo((x+1)*CS, (y+1)*CS); }
                if(cell.w.b && y < S-1) { wallCtx.moveTo(x*CS, (y+1)*CS); wallCtx.lineTo((x+1)*CS, (y+1)*CS); }
            }
        }
        wallCtx.stroke();
    }

    function renderGrid() {
        const grid = document.getElementById('grid');
        grid.innerHTML = '';
        const mId = history[curIdx].id;
        const data = JSON.parse(localStorage.getItem('chroma_secure_zip_lb') || '{}')[mId] || [];
        const heatMap = {}; let maxHeat = 1;
        if(state.gameOver && state.showHeatmap) {
            data.forEach(entry => { if(entry.fullPath) entry.fullPath.forEach(p => {
                const key = `${p.x},${p.y}`; heatMap[key] = (heatMap[key] || 0) + 1;
                if(heatMap[key] > maxHeat) maxHeat = heatMap[key];
            });});
        }
        for(let y=0; y<S; y++) {
            for(let x=0; x<S; x++) {
                const el = document.createElement('div'); el.className = 'cell';
                el.dataset.x = x; el.dataset.y = y;
                if(state.gameOver && state.showHeatmap && heatMap[`${x},${y}`]) {
                    const overlay = document.createElement('div'); overlay.className = 'heatmap-overlay';
                    overlay.style.backgroundColor = `rgba(79, 70, 229, ${heatMap[`${x},${y}`]/maxHeat})`;
                    el.appendChild(overlay);
                }
                for(let [n, p] of Object.entries(state.balls)) {
                    if(p.x === x && p.y === y) {
                        const b = document.createElement('div');
                        b.id = `ball-${n}`; b.className = `ball-anchor ${state.collected.has(parseInt(n))?'collected':''}`;
                        b.style.color = colors[n-1]; b.innerHTML = showNums ? `<span>${n}</span>` : '';
                        el.appendChild(b);
                    }
                }
                grid.appendChild(el);
            }
        }
        document.getElementById('p-count').innerText = state.collected.size;
        document.getElementById('step-count').innerText = Math.max(0, state.path.length - 1);
    }

    function drawPath() {
        pathCtx.clearRect(0, 0, pathCanvas.width, pathCanvas.height);
        if (state.path.length < 1) return;
        pathCtx.lineCap = "round"; pathCtx.lineJoin = "round"; 
        const pathWidth = CS * (14 / 36); 
        pathCtx.lineWidth = pathWidth; 
        
        for (let i = 0; i < state.path.length - 1; i++) {
            pathCtx.beginPath(); pathCtx.strokeStyle = state.path[i].c;
            pathCtx.moveTo(state.path[i].x * CS + CS/2, state.path[i].y * CS + CS/2);
            pathCtx.lineTo(state.path[i+1].x * CS + CS/2, state.path[i+1].y * CS + CS/2);
            pathCtx.stroke();
        }
        const h = state.path[state.path.length - 1];
        pathCtx.beginPath(); pathCtx.fillStyle = h.c;
        pathCtx.arc(h.x * CS + CS/2, h.y * CS + CS/2, pathWidth/2, 0, Math.PI*2);
        pathCtx.fill();
    }

    function moveTowards(nx, ny) {
        if(state.gameOver) return;
        // Strict boundary clamp
        nx = Math.max(0, Math.min(S - 1, nx));
        ny = Math.max(0, Math.min(S - 1, ny));
        
        if (nx === state.player.x && ny === state.player.y) return;
        
        if(!state.startTime) {
            state.startTime = Date.now();
            state.timerInterval = setInterval(() => {
                state.duration = (Date.now() - state.startTime) / 1000;
                document.getElementById('timer').innerText = state.duration.toFixed(1) + "s";
            }, 100);
        }

        const dx = nx - state.player.x, dy = ny - state.player.y;
        if (dx !== 0 && dy !== 0) return; 

        const stepX = Math.sign(dx), stepY = Math.sign(dy);
        let curX = state.player.x, curY = state.player.y;

        while (curX !== nx || curY !== ny) {
            let nextX = curX + stepX, nextY = curY + stepY;
            
            // Loop internal boundary check
            if (nextX < 0 || nextX >= S || nextY < 0 || nextY >= S) break;

            const w = state.cells[curY][curX].w;
            if((stepX === 1 && w.r) || (stepX === -1 && w.l) || (stepY === 1 && w.b) || (stepY === -1 && w.t)) break;

            if (state.path.length > 1) {
                const prev = state.path[state.path.length - 2];
                if (nextX === prev.x && nextY === prev.y) {
                    const head = state.path.pop();
                    const b = Object.entries(state.balls).find(([n, p]) => p.x === head.x && p.y === head.y);
                    if (b && parseInt(b[0]) !== 1) state.collected.delete(parseInt(b[0]));
                    curX = nextX; curY = nextY; state.player = {x: curX, y: curY}; continue;
                }
            }

            if(state.path.some(p => p.x === nextX && p.y === nextY)) {
                if(!(nextX === state.balls[1].x && nextY === state.balls[1].y && state.collected.size === 8)) break;
            }

            curX = nextX; curY = nextY;
            state.player = {x: curX, y: curY};
            let curC = state.path[state.path.length-1].c;

            for(let [n, p] of Object.entries(state.balls)) {
                const num = parseInt(n);
                if(p.x === curX && p.y === curY) {
                    if(num === 1 && state.collected.size === 8) {
                        state.collected.add(1); state.gameOver = true;
                        clearInterval(state.timerInterval); showWin();
                    } else if(num !== 1 && !state.collected.has(num)) {
                        state.collected.add(num); curC = colors[num-1];
                    }
                }
            }
            state.path.push({x: curX, y: curY, c: curC});
        }
        renderGrid(); drawPath();
    }

    function setupInteraction() {
        const zone = document.getElementById('touch-zone');
        const handle = (e) => {
            if (state.gameOver) return;
            const t = e.touches ? e.touches[0] : e;
            const el = document.elementFromPoint(t.clientX, t.clientY);
            if (!el) return;
            const cell = el.closest('.cell');
            if (cell) moveTowards(parseInt(cell.dataset.x), parseInt(cell.dataset.y));
        };
        zone.addEventListener('mousedown', e => { state.isDragging = true; handle(e); });
        window.addEventListener('mousemove', e => { if(state.isDragging) handle(e); });
        window.addEventListener('mouseup', () => state.isDragging = false);
        zone.addEventListener('touchstart', e => { state.isDragging = true; handle(e); }, {passive:false});
        zone.addEventListener('touchmove', e => { if(state.isDragging) { e.preventDefault(); handle(e); } }, {passive:false});
        window.addEventListener('touchend', () => state.isDragging = false);
    }

    function setupKeyboard() {
        window.addEventListener('keydown', (e) => {
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
                e.preventDefault();
                let nx = state.player.x, ny = state.player.y;
                if(e.key === 'ArrowUp') ny--; if(e.key === 'ArrowDown') ny++;
                if(e.key === 'ArrowLeft') nx--; if(e.key === 'ArrowRight') nx++;
                moveTowards(nx, ny);
            }
        });
    }

    function saveScore() {
        const name = (document.getElementById('p-name').value || "ANON").toUpperCase();
        const mId = history[curIdx].id;
        const seq = [...state.collected].join('').substring(0, 9);
        let lbs = JSON.parse(localStorage.getItem('chroma_secure_zip_lb') || '{}');
        if(!lbs[mId]) lbs[mId] = [];
        lbs[mId].push({ name, seq, length: state.path.length, time: state.duration, fullPath: state.path.map(p => ({x: p.x, y: p.y})) });
        localStorage.setItem('chroma_secure_zip_lb', JSON.stringify(lbs));
        document.getElementById('win-modal').style.display = 'none';
        updateLB(); updateAnalytics(); renderGrid();
    }

    function updateLB() {
        const mId = history[curIdx].id;
        const data = JSON.parse(localStorage.getItem('chroma_secure_zip_lb') || '{}')[mId] || [];
        const list = document.getElementById('lb-list');
        list.innerHTML = data.length ? '' : '<div style="color:#94a3b8; font-size:0.6rem; text-align:center;">EMPTY...</div>';
        const group = {};
        data.forEach(e => {
            if(!group[e.seq]) group[e.seq] = { freq: 0, minLen: Infinity, bestUser: "" };
            group[e.seq].freq++;
            if(e.length < group[e.seq].minLen) { group[e.seq].minLen = e.length; group[e.seq].bestUser = e.name; }
        });
        const sorted = Object.entries(group).sort((a,b) => a[1].freq - b[1].freq || a[1].minLen - b[1].minLen);
        sorted.forEach(([seq, s], i) => {
            list.innerHTML += `<div class="lb-item"><div class="lb-rank">${i+1}</div><div><div style="font-weight:800; font-size:0.7rem;">${s.bestUser}</div><div style="font-family:monospace; font-size:0.65rem; color:var(--accent); font-weight:900;">${seq}</div></div><div class="lb-stats">${s.freq} FOUND<br>${s.minLen} STEPS</div></div>`;
        });
    }

    function updateAnalytics() {
        const mId = history[curIdx].id;
        const data = JSON.parse(localStorage.getItem('chroma_secure_zip_lb') || '{}')[mId] || [];
        const histo = document.getElementById('histogram'); histo.innerHTML = '';
        if(data.length === 0) return;
        const seqFreq = {}; data.forEach(e => seqFreq[e.seq] = (seqFreq[e.seq] || 0) + 1);
        const sorted = Object.entries(seqFreq).sort((a,b) => b[1]-a[1]);
        const max = Math.max(...Object.values(seqFreq));
        sorted.forEach(([seq, f]) => {
            const bar = document.createElement('div'); bar.className = 'histo-bar';
            bar.style.height = `${(f / max) * 100}%`; histo.appendChild(bar);
        });
        const playerSeq = [...state.collected].join('').substring(0, 9);
        const rarity = seqFreq[playerSeq] ? (1 - (seqFreq[playerSeq] / data.length)) * 100 : 100;
        document.getElementById('rarity-text').innerText = state.gameOver ? `Path Rarity: ${rarity.toFixed(1)}%` : `Analyzing current zip...`;
    }

    function toggleHeatmap() { state.showHeatmap = !state.showHeatmap; renderGrid(); }
    function changeMaze(d) { if (d === 1 && curIdx === history.length - 1) generate(); curIdx = Math.max(0, Math.min(history.length - 1, curIdx + d)); load(curIdx); }
    function resetMaze() { load(curIdx); }
    function toggleNumbers() { showNums = !showNums; renderGrid(); }
    function showWin() { document.getElementById('win-modal').style.display = 'flex'; document.getElementById('final-stats').innerText = `${state.path.length - 1} Steps | ${state.duration.toFixed(2)}s`; }
    
    init();
</script>
</body>
</html>